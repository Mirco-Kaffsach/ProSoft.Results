using System.Diagnostics.CodeAnalysis;

namespace ProSoft.Results;

/// <summary>
/// Class Result.
/// </summary>
/// <typeparam name="TValue">The type of the t value.</typeparam>
public class Result<TValue> : IDisposable
{
   /// <summary>
   /// Gets or sets the value.
   /// </summary>
   /// <value>The value.</value>
   public TValue? Value { get; set; }

   /// <summary>
   /// Gets or sets the type.
   /// </summary>
   /// <value>The type.</value>
   public ResultType Type { get; set; }

   /// <summary>
   /// Gets or sets the messages.
   /// </summary>
   /// <value>The messages.</value>
   public HashSet<MessageItem> Messages { get; set; } = [];

   /// <summary>
   /// Initializes a new instance of the <see cref="Result{TValue}"/> class.
   /// </summary>
   public Result()
   {

   }

   /// <summary>
   /// Initializes a new instance of the <see cref="Result{TValue}"/> class.
   /// </summary>
   /// <param name="value">The value.</param>
   /// <param name="resultType">Type of the result.</param>
   public Result(TValue? value, ResultType resultType)
   {
      Value = value;
      Type = resultType;
   }

   /// <summary>
   /// Initializes a new instance of the <see cref="Result{TValue}"/> class.
   /// </summary>
   /// <param name="value">The value.</param>
   /// <param name="resultType">Type of the result.</param>
   /// <param name="messages">The messages.</param>
   public Result(TValue? value, ResultType resultType, HashSet<MessageItem> messages)
   {
      Value = value;
      Type = resultType;
      Messages = messages;
   }

   #region IDisposable Interface Implementation

   private bool _disposed;

   /// <summary>
   /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
   /// </summary>
   /// <autogeneratedoc />
   [ExcludeFromCodeCoverage]
   public void Dispose()
   {
      this.Dispose(true);
      GC.SuppressFinalize(this);
   }

   /// <summary>
   /// Releases unmanaged and - optionally - managed resources.
   /// </summary>
   /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
   [ExcludeFromCodeCoverage]
   protected virtual void Dispose(bool disposing)
   {
      if (!_disposed && disposing)
      {
         // Disposing Logic
         Value = default;
         Messages?.Clear();
         Messages = null!;
      }

      _disposed = true;
   }

   /// <summary>
   /// Finalizes an instance of the <see cref="Result{TValue}"/> class.
   /// </summary>
   [ExcludeFromCodeCoverage]
   ~Result()
   {
      this.Dispose(false);
   }

   #endregion
}